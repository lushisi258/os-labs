### 练习

对实验报告的要求：
 - 基于markdown格式来完成，以文本方式为主
 - 填写各个基本练习中要求完成的报告内容
 - 完成实验后，请分析ucore_lab中提供的参考答案，并请在实验报告中说明你的实现与参考答案的区别
 - 列出你认为本实验中重要的知识点，以及与对应的OS原理中的知识点，并简要说明你对二者的含义，关系，差异等方面的理解（也可能出现实验中的知识点没有对应的原理知识点）
 - 列出你认为OS原理中很重要，但在实验中没有对应上的知识点

#### 练习0：填写已有实验

本实验依赖实验1。请把你做的实验1的代码填入本实验中代码中有“LAB1”的注释相应部分并按照实验手册进行进一步的修改。具体来说，就是跟着实验手册的教程一步步做，然后完成教程后继续完成完成exercise部分的剩余练习。

#### 练习1：理解first-fit 连续物理内存分配算法（思考题）
first-fit 连续物理内存分配算法作为物理内存分配一个很基础的方法，需要同学们理解它的实现过程。请大家仔细阅读实验手册的教程并结合`kern/mm/default_pmm.c`中的相关代码，认真分析default_init，default_init_memmap，default_alloc_pages， default_free_pages等相关函数，并描述程序在进行物理内存分配的过程以及各个函数的作用。

##### first-fit 内存分配算法中的函数分析

###### `default_init`
- **功能**: 初始化空闲页列表和空闲页计数器。
- **实现**:
  - 初始化 `free_list` 链表。
  - 将 `nr_free` 设为 0。

###### `default_init_memmap`
- **功能**: 初始化内存页映射。
- **参数**:
  - `base`: 页的基地址。
  - `n`: 页的数量。
- **实现**:
  - 确保 `n` 大于 0。
  - 遍历每个页，重置其标志和引用计数。
  - 设置基页的属性并将其添加到空闲列表中。
  - 更新空闲页计数器 `nr_free`。

###### `default_alloc_pages`
- **功能**: 分配指定数量的页。
- **参数**:
  - `n`: 要分配的页数。
- **实现**:
  - 确保 `n` 大于 0 且不超过空闲页数。
  - 遍历空闲列表，找到合适的页块。
  - 更新页块属性和空闲页计数器。
  - 返回分配的页块。

###### `default_free_pages`
- **功能**: 释放指定数量的页。
- **参数**:
  - `base`: 页的基地址。
  - `n`: 页的数量。
- **实现**:
  - 确保 `n` 大于 0。
  - 遍历每个页，重置其标志和引用计数。
  - 更新基页的属性并将其添加到空闲列表中。
  - 更新空闲页计数器 `nr_free`。
  - 合并相邻的空闲页块。

###### `default_nr_free_pages`
- **功能**: 返回当前空闲页的数量。
- **实现**:
  - 返回 `nr_free` 的值。

###### `basic_check`
- **功能**: 基本的内存分配和释放检查。
- **实现**:
  - 分配和释放页，确保页的正确性和空闲页计数器的正确更新。

###### `default_check`
- **功能**: 检查首次适应分配算法。
- **实现**:
  - 遍历空闲列表，确保页属性正确。
  - 调用 `basic_check` 进行基本检查。
  - 进行复杂的分配和释放操作，确保算法的正确性。

##### 程序在进行物理内存分配过程以及各个函数的作用

**调用过程**
`kern_init` --> `pmm_init` --> `page_init` --> `init_memmap` --> `pmm_manager->init_memmap`

物理内存分配过程主要包括以下几个步骤：初始化内存页、分配页、释放页以及检查内存分配的正确性。以下是详细的过程描述：

1. **初始化内存页**
   - **函数**: `default_init` 和 `default_init_memmap`
   - **过程**:
     - `default_init` 函数初始化空闲页列表 `free_list` 并将空闲页计数器 `nr_free` 设为 0。
     - `default_init_memmap` 函数根据传入的基地址 `base` 和页数 `n` 初始化内存页。它遍历每个页，重置其标志和引用计数，并将基页的属性设置为 `n`，然后将其添加到空闲列表中，更新空闲页计数器 `nr_free`。

2. **分配页**
   - **函数**: `default_alloc_pages`
   - **过程**:
     - `default_alloc_pages` 函数用于分配指定数量的页。首先确保 `n` 大于 0 且不超过当前空闲页数 `nr_free`。
     - 遍历空闲列表，找到一个属性值大于或等于 `n` 的页块。
     - 如果找到合适的页块，则更新页块的属性和空闲页计数器 `nr_free`，并返回分配的页块。

3. **释放页**
   - **函数**: `default_free_pages`
   - **过程**:
     - `default_free_pages` 函数用于释放指定数量的页。首先确保 `n` 大于 0。
     - 遍历每个页，重置其标志和引用计数。
     - 更新基页的属性并将其添加到空闲列表中，更新空闲页计数器 `nr_free`。
     - 检查并合并相邻的空闲页块，以优化内存利用。

4. **检查内存分配的正确性**
   - **函数**: `basic_check` 和 `default_check`
   - **过程**:
     - `basic_check` 函数进行基本的内存分配和释放检查。它分配和释放页，确保页的正确性和空闲页计数器的正确更新。
     - `default_check` 函数进一步检查首次适应分配算法。它遍历空闲列表，确保页属性正确，并进行复杂的分配和释放操作，确保算法的正确性。

##### first fit算法是否有进一步的改进空间？
有，比如内存碎片整理机制

#### 练习2：实现 Best-Fit 连续物理内存分配算法（需要编程）
在完成练习一后，参考kern/mm/default_pmm.c对First Fit算法的实现，编程实现Best Fit页面分配算法，算法的时空复杂度不做要求，能通过测试即可。
请在实验报告中简要说明你的设计实现过程，阐述代码是如何对物理内存进行分配和释放，并回答如下问题：

##### Best-fit 算法的设计实现过程

与first_fit算法不同的地方是，best_fit算法会寻找最小的能够满足需求的内存块，所以具体差异存在于：
**分配内存**
   - 遍历空闲列表，查找最小的、但足够大的空闲块。
   - 如果找到合适的块，将其分割成两部分，一部分分配给请求，另一部分继续作为空闲块。
   - 更新空闲列表。

##### 代码如何对物理内存进行分配和释放

1. **初始化内存管理器**
  best_fit_init：初始化空闲页列表和空闲页数。
  best_fit_init_memmap：初始化内存映射，将一段连续的物理页标记为空闲，并插入到空闲页列表中。

2. **分配页**
  best_fit_alloc_pages：寻找最佳适配的页块（即最小的满足请求的连续页块），从空闲页列表中删除该页块，并更新空闲页数。如果页块大于请求的页数，则将剩余部分重新插入空闲页列表。

3. **释放页**
  best_fit_free_pages：将释放的页块插入空闲页列表，并尝试与相邻的空闲页块合并，更新空闲页数。

4. **获取空闲页数**
  best_fit_nr_free_pages：返回当前空闲页数。

5. **检查内存管理器**
  basic_check 和 best_fit_check：用于检查内存管理器的正确性，包括分配和释放页的基本操作。

##### Best-Fit 算法是否有进一步的改进空间？

有，比如增加内存碎片优化机制

#### 扩展练习Challenge：buddy system（伙伴系统）分配算法（需要编程）

Buddy System算法把系统中的可用存储空间划分为存储块(Block)来进行管理, 每个存储块的大小必须是2的n次幂(Pow(2, n)), 即1, 2, 4, 8, 16, 32, 64, 128...

 -  参考[伙伴分配器的一个极简实现](http://coolshell.cn/articles/10427.html)， 在ucore中实现buddy system分配算法，要求有比较充分的测试用例说明实现的正确性，需要有设计文档。
 
#### 扩展练习Challenge：任意大小的内存单元slub分配算法（需要编程）

slub算法，实现两层架构的高效内存单元分配，第一层是基于页大小的内存分配，第二层是在第一层基础上实现基于任意大小的内存分配。可简化实现，能够体现其主体思想即可。

 - 参考[linux的slub分配算法/](http://www.ibm.com/developerworks/cn/linux/l-cn-slub/)，在ucore中实现slub分配算法。要求有比较充分的测试用例说明实现的正确性，需要有设计文档。

#### 扩展练习Challenge：硬件的可用物理内存范围的获取方法（思考题）
  - **如果 OS 无法提前知道当前硬件的可用物理内存范围，请问你有何办法让 OS 获取可用物理内存范围？**
  1. 设备树
  加载设备树：QEMU 启动时会传递一个设备树文件（.dtb）给操作系统。
  解析设备树：操作系统在启动时解析设备树文件，从 /memory 节点中提取内存信息。
  2. 固件接口
  调用 OpenSBI 接口：操作系统在启动时调用 OpenSBI 提供的接口（如 sbi_get_memory_info）来获取内存布局。

> Challenges是选做，完成Challenge的同学可单独提交Challenge。完成得好的同学可获得最终考试成绩的加分。